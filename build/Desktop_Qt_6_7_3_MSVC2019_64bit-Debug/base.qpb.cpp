/* This file is autogenerated. DO NOT CHANGE. All changes will be lost */

#include "base.qpb.h"
#include <QtProtobuf/qprotobufserializer.h>
#include <cmath>

namespace bite_im {
static QtProtobuf::ProtoTypeRegistrar ProtoTypeRegistrarMessageTypeGadget(MessageTypeGadget::registerTypes);
void MessageTypeGadget::registerTypes()
{
    qRegisterMetaType<MessageType>();
    qRegisterMetaType<bite_im::MessageTypeGadget::MessageType>();
    qRegisterProtobufEnumType<bite_im::MessageTypeGadget::MessageType>();
}


class UserInfo_QtProtobufData : public QSharedData
{
public:
    UserInfo_QtProtobufData()
        : QSharedData()
    {
    }

    UserInfo_QtProtobufData(const UserInfo_QtProtobufData &other)
        : QSharedData(other),
          m_userId(other.m_userId),
          m_nickname(other.m_nickname),
          m_description(other.m_description),
          m_phone(other.m_phone),
          m_avatar(other.m_avatar)
    {
    }

    QString m_userId;
    QString m_nickname;
    QString m_description;
    QString m_phone;
    QByteArray m_avatar;
};

UserInfo::~UserInfo() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 21> qt_protobuf_UserInfo_uint_data;
    const char qt_protobuf_UserInfo_char_data[59];
} qt_protobuf_UserInfo_metadata {
    // data
    {
        0, /* = version */
        5, /* = num fields */
        6, /* = field number offset */
        11, /* = property index offset */
        16, /* = field flags offset */
        16, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        17, /* = userId */
        24, /* = nickname */
        33, /* = description */
        45, /* = phone */
        51, /* = avatar */
        58, /* = end-of-string-marker */
        // Field numbers:
        1, /* = userId */
        2, /* = nickname */
        3, /* = description */
        4, /* = phone */
        5, /* = avatar */
        // Property indices:
        0, /* = userId */
        1, /* = nickname */
        2, /* = description */
        3, /* = phone */
        4, /* = avatar */
        // Field flags:
        QtProtobufPrivate::NoFlags, /* = userId */
        QtProtobufPrivate::NoFlags, /* = nickname */
        QtProtobufPrivate::NoFlags, /* = description */
        QtProtobufPrivate::NoFlags, /* = phone */
        QtProtobufPrivate::NoFlags, /* = avatar */
    },
    // char_data
    /* metadata char_data: */
    "bite_im.UserInfo\0" /* = full message name */
    /* field char_data: */
    "userId\0nickname\0description\0phone\0avatar\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering UserInfo::propertyOrdering = {
    &qt_protobuf_UserInfo_metadata.data
};

void UserInfo::registerTypes()
{
    qRegisterMetaType<UserInfo>();
    qRegisterMetaType<UserInfoRepeated>();
}

UserInfo::UserInfo()
    : QProtobufMessage(&UserInfo::staticMetaObject),
      dptr(new UserInfo_QtProtobufData)
{
}

UserInfo::UserInfo(const UserInfo &other)
    : QProtobufMessage(other),
      dptr(other.dptr)
{
}
UserInfo &UserInfo::operator =(const UserInfo &other)
{
    QProtobufMessage::operator=(other);
    dptr = other.dptr;
    return *this;
}
UserInfo::UserInfo(UserInfo &&other) noexcept
    : QProtobufMessage(std::move(other)),
      dptr(std::move(other.dptr))
{
}
UserInfo &UserInfo::operator =(UserInfo &&other) noexcept
{
    QProtobufMessage::operator=(std::move(other));
    dptr.swap(other.dptr);
    return *this;
}
bool UserInfo::operator ==(const UserInfo &other) const
{
    return QProtobufMessage::isEqual(*this, other)
        && dptr->m_userId == other.dptr->m_userId
        && dptr->m_nickname == other.dptr->m_nickname
        && dptr->m_description == other.dptr->m_description
        && dptr->m_phone == other.dptr->m_phone
        && dptr->m_avatar == other.dptr->m_avatar;
}

bool UserInfo::operator !=(const UserInfo &other) const
{
    return !this->operator ==(other);
}

QString UserInfo::userId() const
{
    return dptr->m_userId;
}

QString UserInfo::nickname() const
{
    return dptr->m_nickname;
}

QString UserInfo::description() const
{
    return dptr->m_description;
}

QString UserInfo::phone() const
{
    return dptr->m_phone;
}

QByteArray UserInfo::avatar() const
{
    return dptr->m_avatar;
}

void UserInfo::setUserId(const QString &userId)
{
    if (dptr->m_userId != userId) {
        dptr.detach();
        dptr->m_userId = userId;
    }
}

void UserInfo::setNickname(const QString &nickname)
{
    if (dptr->m_nickname != nickname) {
        dptr.detach();
        dptr->m_nickname = nickname;
    }
}

void UserInfo::setDescription(const QString &description)
{
    if (dptr->m_description != description) {
        dptr.detach();
        dptr->m_description = description;
    }
}

void UserInfo::setPhone(const QString &phone)
{
    if (dptr->m_phone != phone) {
        dptr.detach();
        dptr->m_phone = phone;
    }
}

void UserInfo::setAvatar(const QByteArray &avatar)
{
    if (dptr->m_avatar != avatar) {
        dptr.detach();
        dptr->m_avatar = avatar;
    }
}


class ChatSessionInfo_QtProtobufData : public QSharedData
{
public:
    ChatSessionInfo_QtProtobufData()
        : QSharedData(),
          m_prevMessage(nullptr)
    {
    }

    ChatSessionInfo_QtProtobufData(const ChatSessionInfo_QtProtobufData &other)
        : QSharedData(other),
          m_singleChatFriendId(other.m_singleChatFriendId),
          m_chatSessionId(other.m_chatSessionId),
          m_chatSessionName(other.m_chatSessionName),
          m_prevMessage(other.m_prevMessage
                                               ? new MessageInfo(*other.m_prevMessage)
                                               : nullptr),
          m_avatar(other.m_avatar)
    {
    }

    std::optional<QString> m_singleChatFriendId;
    QString m_chatSessionId;
    QString m_chatSessionName;
    QtProtobufPrivate::QProtobufLazyMessagePointer<MessageInfo> m_prevMessage;
    std::optional<QByteArray> m_avatar;
};

ChatSessionInfo::~ChatSessionInfo() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 21> qt_protobuf_ChatSessionInfo_uint_data;
    const char qt_protobuf_ChatSessionInfo_char_data[93];
} qt_protobuf_ChatSessionInfo_metadata {
    // data
    {
        0, /* = version */
        5, /* = num fields */
        6, /* = field number offset */
        11, /* = property index offset */
        16, /* = field flags offset */
        23, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        24, /* = singleChatFriendId */
        43, /* = chatSessionId */
        57, /* = chatSessionName */
        73, /* = prevMessage */
        85, /* = avatar */
        92, /* = end-of-string-marker */
        // Field numbers:
        1, /* = singleChatFriendId */
        2, /* = chatSessionId */
        3, /* = chatSessionName */
        4, /* = prevMessage */
        5, /* = avatar */
        // Property indices:
        0, /* = singleChatFriendId */
        2, /* = chatSessionId */
        3, /* = chatSessionName */
        4, /* = prevMessage */
        5, /* = avatar */
        // Field flags:
        QtProtobufPrivate::Optional, /* = singleChatFriendId */
        QtProtobufPrivate::NoFlags, /* = chatSessionId */
        QtProtobufPrivate::NoFlags, /* = chatSessionName */
        QtProtobufPrivate::NoFlags, /* = prevMessage */
        QtProtobufPrivate::Optional, /* = avatar */
    },
    // char_data
    /* metadata char_data: */
    "bite_im.ChatSessionInfo\0" /* = full message name */
    /* field char_data: */
    "singleChatFriendId\0chatSessionId\0chatSessionName\0prevMessage\0avatar\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering ChatSessionInfo::propertyOrdering = {
    &qt_protobuf_ChatSessionInfo_metadata.data
};

void ChatSessionInfo::registerTypes()
{
    qRegisterMetaType<ChatSessionInfo>();
    qRegisterMetaType<ChatSessionInfoRepeated>();
}

ChatSessionInfo::ChatSessionInfo()
    : QProtobufMessage(&ChatSessionInfo::staticMetaObject),
      dptr(new ChatSessionInfo_QtProtobufData)
{
}

ChatSessionInfo::ChatSessionInfo(const ChatSessionInfo &other)
    : QProtobufMessage(other),
      dptr(other.dptr)
{
}
ChatSessionInfo &ChatSessionInfo::operator =(const ChatSessionInfo &other)
{
    QProtobufMessage::operator=(other);
    dptr = other.dptr;
    return *this;
}
ChatSessionInfo::ChatSessionInfo(ChatSessionInfo &&other) noexcept
    : QProtobufMessage(std::move(other)),
      dptr(std::move(other.dptr))
{
}
ChatSessionInfo &ChatSessionInfo::operator =(ChatSessionInfo &&other) noexcept
{
    QProtobufMessage::operator=(std::move(other));
    dptr.swap(other.dptr);
    return *this;
}
bool ChatSessionInfo::operator ==(const ChatSessionInfo &other) const
{
    return QProtobufMessage::isEqual(*this, other)
        && dptr->m_singleChatFriendId == other.dptr->m_singleChatFriendId
        && dptr->m_chatSessionId == other.dptr->m_chatSessionId
        && dptr->m_chatSessionName == other.dptr->m_chatSessionName
        && (dptr->m_prevMessage == other.dptr->m_prevMessage
            || *dptr->m_prevMessage == *other.dptr->m_prevMessage)
        && dptr->m_avatar == other.dptr->m_avatar;
}

bool ChatSessionInfo::operator !=(const ChatSessionInfo &other) const
{
    return !this->operator ==(other);
}

QString ChatSessionInfo::singleChatFriendId_p() const
{
    return dptr->m_singleChatFriendId ?
        dptr->m_singleChatFriendId.value() : QString();
}

bool ChatSessionInfo::hasSingleChatFriendId() const
{
    return dptr->m_singleChatFriendId.has_value();
}
QString ChatSessionInfo::singleChatFriendId() const
{
    Q_ASSERT(dptr->m_singleChatFriendId.has_value());
    return dptr->m_singleChatFriendId.value();
}

QString ChatSessionInfo::chatSessionId() const
{
    return dptr->m_chatSessionId;
}

QString ChatSessionInfo::chatSessionName() const
{
    return dptr->m_chatSessionName;
}

MessageInfo *ChatSessionInfo::prevMessage_p() const
{
    return dptr->m_prevMessage ? dptr->m_prevMessage.get() : nullptr;
}

bool ChatSessionInfo::hasPrevMessage() const
{
    return dptr->m_prevMessage.operator bool();
}

MessageInfo &ChatSessionInfo::prevMessage()
{
    dptr.detach();
    return *dptr->m_prevMessage;
}
const MessageInfo &ChatSessionInfo::prevMessage() const
{
    return *dptr->m_prevMessage;
}

void ChatSessionInfo::clearPrevMessage()
{
    if (dptr->m_prevMessage) {
        dptr.detach();
        dptr->m_prevMessage.reset();
    }
}

QByteArray ChatSessionInfo::avatar_p() const
{
    return dptr->m_avatar ?
        dptr->m_avatar.value() : QByteArray();
}

bool ChatSessionInfo::hasAvatar() const
{
    return dptr->m_avatar.has_value();
}
QByteArray ChatSessionInfo::avatar() const
{
    Q_ASSERT(dptr->m_avatar.has_value());
    return dptr->m_avatar.value();
}

void ChatSessionInfo::setSingleChatFriendId(const QString &singleChatFriendId)
{
    if (!dptr->m_singleChatFriendId || dptr->m_singleChatFriendId.value() != singleChatFriendId) {
        dptr.detach();
        dptr->m_singleChatFriendId = singleChatFriendId;
    }
}

void ChatSessionInfo::setSingleChatFriendId_p(QString singleChatFriendId)
{
    if (!dptr->m_singleChatFriendId || dptr->m_singleChatFriendId != singleChatFriendId) {
        dptr.detach();
        dptr->m_singleChatFriendId = singleChatFriendId;
    }
}

void ChatSessionInfo::clearSingleChatFriendId()
{
    if (dptr->m_singleChatFriendId.has_value()) {
        dptr.detach();
        dptr->m_singleChatFriendId.reset();
    }
}
void ChatSessionInfo::setChatSessionId(const QString &chatSessionId)
{
    if (dptr->m_chatSessionId != chatSessionId) {
        dptr.detach();
        dptr->m_chatSessionId = chatSessionId;
    }
}

void ChatSessionInfo::setChatSessionName(const QString &chatSessionName)
{
    if (dptr->m_chatSessionName != chatSessionName) {
        dptr.detach();
        dptr->m_chatSessionName = chatSessionName;
    }
}

void ChatSessionInfo::setPrevMessage_p(MessageInfo *prevMessage)
{
    if (dptr->m_prevMessage.get() != prevMessage) {
        dptr.detach();
        dptr->m_prevMessage.reset(prevMessage);
    }
}

void ChatSessionInfo::setPrevMessage(const MessageInfo &prevMessage)
{
    if (*dptr->m_prevMessage != prevMessage) {
        dptr.detach();
        *dptr->m_prevMessage = prevMessage;
    }
}

void ChatSessionInfo::setAvatar(const QByteArray &avatar)
{
    if (!dptr->m_avatar || dptr->m_avatar.value() != avatar) {
        dptr.detach();
        dptr->m_avatar = avatar;
    }
}

void ChatSessionInfo::setAvatar_p(QByteArray avatar)
{
    if (!dptr->m_avatar || dptr->m_avatar != avatar) {
        dptr.detach();
        dptr->m_avatar = avatar;
    }
}

void ChatSessionInfo::clearAvatar()
{
    if (dptr->m_avatar.has_value()) {
        dptr.detach();
        dptr->m_avatar.reset();
    }
}

class StringMessageInfo_QtProtobufData : public QSharedData
{
public:
    StringMessageInfo_QtProtobufData()
        : QSharedData()
    {
    }

    StringMessageInfo_QtProtobufData(const StringMessageInfo_QtProtobufData &other)
        : QSharedData(other),
          m_content(other.m_content)
    {
    }

    QString m_content;
};

StringMessageInfo::~StringMessageInfo() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 5> qt_protobuf_StringMessageInfo_uint_data;
    const char qt_protobuf_StringMessageInfo_char_data[35];
} qt_protobuf_StringMessageInfo_metadata {
    // data
    {
        0, /* = version */
        1, /* = num fields */
        2, /* = field number offset */
        3, /* = property index offset */
        4, /* = field flags offset */
        25, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        26, /* = content */
        34, /* = end-of-string-marker */
        // Field numbers:
        1, /* = content */
        // Property indices:
        0, /* = content */
        // Field flags:
        QtProtobufPrivate::NoFlags, /* = content */
    },
    // char_data
    /* metadata char_data: */
    "bite_im.StringMessageInfo\0" /* = full message name */
    /* field char_data: */
    "content\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering StringMessageInfo::propertyOrdering = {
    &qt_protobuf_StringMessageInfo_metadata.data
};

void StringMessageInfo::registerTypes()
{
    qRegisterMetaType<StringMessageInfo>();
    qRegisterMetaType<StringMessageInfoRepeated>();
}

StringMessageInfo::StringMessageInfo()
    : QProtobufMessage(&StringMessageInfo::staticMetaObject),
      dptr(new StringMessageInfo_QtProtobufData)
{
}

StringMessageInfo::StringMessageInfo(const StringMessageInfo &other)
    : QProtobufMessage(other),
      dptr(other.dptr)
{
}
StringMessageInfo &StringMessageInfo::operator =(const StringMessageInfo &other)
{
    QProtobufMessage::operator=(other);
    dptr = other.dptr;
    return *this;
}
StringMessageInfo::StringMessageInfo(StringMessageInfo &&other) noexcept
    : QProtobufMessage(std::move(other)),
      dptr(std::move(other.dptr))
{
}
StringMessageInfo &StringMessageInfo::operator =(StringMessageInfo &&other) noexcept
{
    QProtobufMessage::operator=(std::move(other));
    dptr.swap(other.dptr);
    return *this;
}
bool StringMessageInfo::operator ==(const StringMessageInfo &other) const
{
    return QProtobufMessage::isEqual(*this, other)
        && dptr->m_content == other.dptr->m_content;
}

bool StringMessageInfo::operator !=(const StringMessageInfo &other) const
{
    return !this->operator ==(other);
}

QString StringMessageInfo::content() const
{
    return dptr->m_content;
}

void StringMessageInfo::setContent(const QString &content)
{
    if (dptr->m_content != content) {
        dptr.detach();
        dptr->m_content = content;
    }
}


class ImageMessageInfo_QtProtobufData : public QSharedData
{
public:
    ImageMessageInfo_QtProtobufData()
        : QSharedData()
    {
    }

    ImageMessageInfo_QtProtobufData(const ImageMessageInfo_QtProtobufData &other)
        : QSharedData(other),
          m_fileId(other.m_fileId),
          m_imageContent(other.m_imageContent)
    {
    }

    std::optional<QString> m_fileId;
    std::optional<QByteArray> m_imageContent;
};

ImageMessageInfo::~ImageMessageInfo() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 9> qt_protobuf_ImageMessageInfo_uint_data;
    const char qt_protobuf_ImageMessageInfo_char_data[46];
} qt_protobuf_ImageMessageInfo_metadata {
    // data
    {
        0, /* = version */
        2, /* = num fields */
        3, /* = field number offset */
        5, /* = property index offset */
        7, /* = field flags offset */
        24, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        25, /* = fileId */
        32, /* = imageContent */
        45, /* = end-of-string-marker */
        // Field numbers:
        1, /* = fileId */
        2, /* = imageContent */
        // Property indices:
        0, /* = fileId */
        2, /* = imageContent */
        // Field flags:
        QtProtobufPrivate::Optional, /* = fileId */
        QtProtobufPrivate::Optional, /* = imageContent */
    },
    // char_data
    /* metadata char_data: */
    "bite_im.ImageMessageInfo\0" /* = full message name */
    /* field char_data: */
    "fileId\0imageContent\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering ImageMessageInfo::propertyOrdering = {
    &qt_protobuf_ImageMessageInfo_metadata.data
};

void ImageMessageInfo::registerTypes()
{
    qRegisterMetaType<ImageMessageInfo>();
    qRegisterMetaType<ImageMessageInfoRepeated>();
}

ImageMessageInfo::ImageMessageInfo()
    : QProtobufMessage(&ImageMessageInfo::staticMetaObject),
      dptr(new ImageMessageInfo_QtProtobufData)
{
}

ImageMessageInfo::ImageMessageInfo(const ImageMessageInfo &other)
    : QProtobufMessage(other),
      dptr(other.dptr)
{
}
ImageMessageInfo &ImageMessageInfo::operator =(const ImageMessageInfo &other)
{
    QProtobufMessage::operator=(other);
    dptr = other.dptr;
    return *this;
}
ImageMessageInfo::ImageMessageInfo(ImageMessageInfo &&other) noexcept
    : QProtobufMessage(std::move(other)),
      dptr(std::move(other.dptr))
{
}
ImageMessageInfo &ImageMessageInfo::operator =(ImageMessageInfo &&other) noexcept
{
    QProtobufMessage::operator=(std::move(other));
    dptr.swap(other.dptr);
    return *this;
}
bool ImageMessageInfo::operator ==(const ImageMessageInfo &other) const
{
    return QProtobufMessage::isEqual(*this, other)
        && dptr->m_fileId == other.dptr->m_fileId
        && dptr->m_imageContent == other.dptr->m_imageContent;
}

bool ImageMessageInfo::operator !=(const ImageMessageInfo &other) const
{
    return !this->operator ==(other);
}

QString ImageMessageInfo::fileId_p() const
{
    return dptr->m_fileId ?
        dptr->m_fileId.value() : QString();
}

bool ImageMessageInfo::hasFileId() const
{
    return dptr->m_fileId.has_value();
}
QString ImageMessageInfo::fileId() const
{
    Q_ASSERT(dptr->m_fileId.has_value());
    return dptr->m_fileId.value();
}

QByteArray ImageMessageInfo::imageContent_p() const
{
    return dptr->m_imageContent ?
        dptr->m_imageContent.value() : QByteArray();
}

bool ImageMessageInfo::hasImageContent() const
{
    return dptr->m_imageContent.has_value();
}
QByteArray ImageMessageInfo::imageContent() const
{
    Q_ASSERT(dptr->m_imageContent.has_value());
    return dptr->m_imageContent.value();
}

void ImageMessageInfo::setFileId(const QString &fileId)
{
    if (!dptr->m_fileId || dptr->m_fileId.value() != fileId) {
        dptr.detach();
        dptr->m_fileId = fileId;
    }
}

void ImageMessageInfo::setFileId_p(QString fileId)
{
    if (!dptr->m_fileId || dptr->m_fileId != fileId) {
        dptr.detach();
        dptr->m_fileId = fileId;
    }
}

void ImageMessageInfo::clearFileId()
{
    if (dptr->m_fileId.has_value()) {
        dptr.detach();
        dptr->m_fileId.reset();
    }
}
void ImageMessageInfo::setImageContent(const QByteArray &imageContent)
{
    if (!dptr->m_imageContent || dptr->m_imageContent.value() != imageContent) {
        dptr.detach();
        dptr->m_imageContent = imageContent;
    }
}

void ImageMessageInfo::setImageContent_p(QByteArray imageContent)
{
    if (!dptr->m_imageContent || dptr->m_imageContent != imageContent) {
        dptr.detach();
        dptr->m_imageContent = imageContent;
    }
}

void ImageMessageInfo::clearImageContent()
{
    if (dptr->m_imageContent.has_value()) {
        dptr.detach();
        dptr->m_imageContent.reset();
    }
}

class FileMessageInfo_QtProtobufData : public QSharedData
{
public:
    FileMessageInfo_QtProtobufData()
        : QSharedData(),
          m_fileSize(0)
    {
    }

    FileMessageInfo_QtProtobufData(const FileMessageInfo_QtProtobufData &other)
        : QSharedData(other),
          m_fileId(other.m_fileId),
          m_fileSize(other.m_fileSize),
          m_fileName(other.m_fileName),
          m_fileContents(other.m_fileContents)
    {
    }

    std::optional<QString> m_fileId;
    QtProtobuf::int64 m_fileSize;
    QString m_fileName;
    std::optional<QByteArray> m_fileContents;
};

FileMessageInfo::~FileMessageInfo() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 17> qt_protobuf_FileMessageInfo_uint_data;
    const char qt_protobuf_FileMessageInfo_char_data[63];
} qt_protobuf_FileMessageInfo_metadata {
    // data
    {
        0, /* = version */
        4, /* = num fields */
        5, /* = field number offset */
        9, /* = property index offset */
        13, /* = field flags offset */
        23, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        24, /* = fileId */
        31, /* = fileSize */
        40, /* = fileName */
        49, /* = fileContents */
        62, /* = end-of-string-marker */
        // Field numbers:
        1, /* = fileId */
        2, /* = fileSize */
        3, /* = fileName */
        4, /* = fileContents */
        // Property indices:
        0, /* = fileId */
        2, /* = fileSize */
        3, /* = fileName */
        4, /* = fileContents */
        // Field flags:
        QtProtobufPrivate::Optional, /* = fileId */
        QtProtobufPrivate::NoFlags, /* = fileSize */
        QtProtobufPrivate::NoFlags, /* = fileName */
        QtProtobufPrivate::Optional, /* = fileContents */
    },
    // char_data
    /* metadata char_data: */
    "bite_im.FileMessageInfo\0" /* = full message name */
    /* field char_data: */
    "fileId\0fileSize\0fileName\0fileContents\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering FileMessageInfo::propertyOrdering = {
    &qt_protobuf_FileMessageInfo_metadata.data
};

void FileMessageInfo::registerTypes()
{
    qRegisterMetaType<FileMessageInfo>();
    qRegisterMetaType<FileMessageInfoRepeated>();
}

FileMessageInfo::FileMessageInfo()
    : QProtobufMessage(&FileMessageInfo::staticMetaObject),
      dptr(new FileMessageInfo_QtProtobufData)
{
}

FileMessageInfo::FileMessageInfo(const FileMessageInfo &other)
    : QProtobufMessage(other),
      dptr(other.dptr)
{
}
FileMessageInfo &FileMessageInfo::operator =(const FileMessageInfo &other)
{
    QProtobufMessage::operator=(other);
    dptr = other.dptr;
    return *this;
}
FileMessageInfo::FileMessageInfo(FileMessageInfo &&other) noexcept
    : QProtobufMessage(std::move(other)),
      dptr(std::move(other.dptr))
{
}
FileMessageInfo &FileMessageInfo::operator =(FileMessageInfo &&other) noexcept
{
    QProtobufMessage::operator=(std::move(other));
    dptr.swap(other.dptr);
    return *this;
}
bool FileMessageInfo::operator ==(const FileMessageInfo &other) const
{
    return QProtobufMessage::isEqual(*this, other)
        && dptr->m_fileId == other.dptr->m_fileId
        && dptr->m_fileSize == other.dptr->m_fileSize
        && dptr->m_fileName == other.dptr->m_fileName
        && dptr->m_fileContents == other.dptr->m_fileContents;
}

bool FileMessageInfo::operator !=(const FileMessageInfo &other) const
{
    return !this->operator ==(other);
}

QString FileMessageInfo::fileId_p() const
{
    return dptr->m_fileId ?
        dptr->m_fileId.value() : QString();
}

bool FileMessageInfo::hasFileId() const
{
    return dptr->m_fileId.has_value();
}
QString FileMessageInfo::fileId() const
{
    Q_ASSERT(dptr->m_fileId.has_value());
    return dptr->m_fileId.value();
}

QtProtobuf::int64 FileMessageInfo::fileSize() const
{
    return dptr->m_fileSize;
}

QString FileMessageInfo::fileName() const
{
    return dptr->m_fileName;
}

QByteArray FileMessageInfo::fileContents_p() const
{
    return dptr->m_fileContents ?
        dptr->m_fileContents.value() : QByteArray();
}

bool FileMessageInfo::hasFileContents() const
{
    return dptr->m_fileContents.has_value();
}
QByteArray FileMessageInfo::fileContents() const
{
    Q_ASSERT(dptr->m_fileContents.has_value());
    return dptr->m_fileContents.value();
}

void FileMessageInfo::setFileId(const QString &fileId)
{
    if (!dptr->m_fileId || dptr->m_fileId.value() != fileId) {
        dptr.detach();
        dptr->m_fileId = fileId;
    }
}

void FileMessageInfo::setFileId_p(QString fileId)
{
    if (!dptr->m_fileId || dptr->m_fileId != fileId) {
        dptr.detach();
        dptr->m_fileId = fileId;
    }
}

void FileMessageInfo::clearFileId()
{
    if (dptr->m_fileId.has_value()) {
        dptr.detach();
        dptr->m_fileId.reset();
    }
}
void FileMessageInfo::setFileSize(const QtProtobuf::int64 &fileSize)
{
    if (dptr->m_fileSize != fileSize) {
        dptr.detach();
        dptr->m_fileSize = fileSize;
    }
}

void FileMessageInfo::setFileName(const QString &fileName)
{
    if (dptr->m_fileName != fileName) {
        dptr.detach();
        dptr->m_fileName = fileName;
    }
}

void FileMessageInfo::setFileContents(const QByteArray &fileContents)
{
    if (!dptr->m_fileContents || dptr->m_fileContents.value() != fileContents) {
        dptr.detach();
        dptr->m_fileContents = fileContents;
    }
}

void FileMessageInfo::setFileContents_p(QByteArray fileContents)
{
    if (!dptr->m_fileContents || dptr->m_fileContents != fileContents) {
        dptr.detach();
        dptr->m_fileContents = fileContents;
    }
}

void FileMessageInfo::clearFileContents()
{
    if (dptr->m_fileContents.has_value()) {
        dptr.detach();
        dptr->m_fileContents.reset();
    }
}

class SpeechMessageInfo_QtProtobufData : public QSharedData
{
public:
    SpeechMessageInfo_QtProtobufData()
        : QSharedData()
    {
    }

    SpeechMessageInfo_QtProtobufData(const SpeechMessageInfo_QtProtobufData &other)
        : QSharedData(other),
          m_fileId(other.m_fileId),
          m_fileContents(other.m_fileContents)
    {
    }

    std::optional<QString> m_fileId;
    std::optional<QByteArray> m_fileContents;
};

SpeechMessageInfo::~SpeechMessageInfo() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 9> qt_protobuf_SpeechMessageInfo_uint_data;
    const char qt_protobuf_SpeechMessageInfo_char_data[47];
} qt_protobuf_SpeechMessageInfo_metadata {
    // data
    {
        0, /* = version */
        2, /* = num fields */
        3, /* = field number offset */
        5, /* = property index offset */
        7, /* = field flags offset */
        25, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        26, /* = fileId */
        33, /* = fileContents */
        46, /* = end-of-string-marker */
        // Field numbers:
        1, /* = fileId */
        2, /* = fileContents */
        // Property indices:
        0, /* = fileId */
        2, /* = fileContents */
        // Field flags:
        QtProtobufPrivate::Optional, /* = fileId */
        QtProtobufPrivate::Optional, /* = fileContents */
    },
    // char_data
    /* metadata char_data: */
    "bite_im.SpeechMessageInfo\0" /* = full message name */
    /* field char_data: */
    "fileId\0fileContents\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering SpeechMessageInfo::propertyOrdering = {
    &qt_protobuf_SpeechMessageInfo_metadata.data
};

void SpeechMessageInfo::registerTypes()
{
    qRegisterMetaType<SpeechMessageInfo>();
    qRegisterMetaType<SpeechMessageInfoRepeated>();
}

SpeechMessageInfo::SpeechMessageInfo()
    : QProtobufMessage(&SpeechMessageInfo::staticMetaObject),
      dptr(new SpeechMessageInfo_QtProtobufData)
{
}

SpeechMessageInfo::SpeechMessageInfo(const SpeechMessageInfo &other)
    : QProtobufMessage(other),
      dptr(other.dptr)
{
}
SpeechMessageInfo &SpeechMessageInfo::operator =(const SpeechMessageInfo &other)
{
    QProtobufMessage::operator=(other);
    dptr = other.dptr;
    return *this;
}
SpeechMessageInfo::SpeechMessageInfo(SpeechMessageInfo &&other) noexcept
    : QProtobufMessage(std::move(other)),
      dptr(std::move(other.dptr))
{
}
SpeechMessageInfo &SpeechMessageInfo::operator =(SpeechMessageInfo &&other) noexcept
{
    QProtobufMessage::operator=(std::move(other));
    dptr.swap(other.dptr);
    return *this;
}
bool SpeechMessageInfo::operator ==(const SpeechMessageInfo &other) const
{
    return QProtobufMessage::isEqual(*this, other)
        && dptr->m_fileId == other.dptr->m_fileId
        && dptr->m_fileContents == other.dptr->m_fileContents;
}

bool SpeechMessageInfo::operator !=(const SpeechMessageInfo &other) const
{
    return !this->operator ==(other);
}

QString SpeechMessageInfo::fileId_p() const
{
    return dptr->m_fileId ?
        dptr->m_fileId.value() : QString();
}

bool SpeechMessageInfo::hasFileId() const
{
    return dptr->m_fileId.has_value();
}
QString SpeechMessageInfo::fileId() const
{
    Q_ASSERT(dptr->m_fileId.has_value());
    return dptr->m_fileId.value();
}

QByteArray SpeechMessageInfo::fileContents_p() const
{
    return dptr->m_fileContents ?
        dptr->m_fileContents.value() : QByteArray();
}

bool SpeechMessageInfo::hasFileContents() const
{
    return dptr->m_fileContents.has_value();
}
QByteArray SpeechMessageInfo::fileContents() const
{
    Q_ASSERT(dptr->m_fileContents.has_value());
    return dptr->m_fileContents.value();
}

void SpeechMessageInfo::setFileId(const QString &fileId)
{
    if (!dptr->m_fileId || dptr->m_fileId.value() != fileId) {
        dptr.detach();
        dptr->m_fileId = fileId;
    }
}

void SpeechMessageInfo::setFileId_p(QString fileId)
{
    if (!dptr->m_fileId || dptr->m_fileId != fileId) {
        dptr.detach();
        dptr->m_fileId = fileId;
    }
}

void SpeechMessageInfo::clearFileId()
{
    if (dptr->m_fileId.has_value()) {
        dptr.detach();
        dptr->m_fileId.reset();
    }
}
void SpeechMessageInfo::setFileContents(const QByteArray &fileContents)
{
    if (!dptr->m_fileContents || dptr->m_fileContents.value() != fileContents) {
        dptr.detach();
        dptr->m_fileContents = fileContents;
    }
}

void SpeechMessageInfo::setFileContents_p(QByteArray fileContents)
{
    if (!dptr->m_fileContents || dptr->m_fileContents != fileContents) {
        dptr.detach();
        dptr->m_fileContents = fileContents;
    }
}

void SpeechMessageInfo::clearFileContents()
{
    if (dptr->m_fileContents.has_value()) {
        dptr.detach();
        dptr->m_fileContents.reset();
    }
}

class MessageContent_QtProtobufData : public QSharedData
{
public:
    MessageContent_QtProtobufData()
        : QSharedData(),
          m_messageType(MessageTypeGadget::MessageType::STRING)
    {
    }

    MessageContent_QtProtobufData(const MessageContent_QtProtobufData &other)
        : QSharedData(other),
          m_messageType(other.m_messageType),
          m_msg_content(other.m_msg_content)
    {
    }

    MessageTypeGadget::MessageType m_messageType;
    QtProtobufPrivate::QProtobufOneof m_msg_content;
};

MessageContent::~MessageContent() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 21> qt_protobuf_MessageContent_uint_data;
    const char qt_protobuf_MessageContent_char_data[89];
} qt_protobuf_MessageContent_metadata {
    // data
    {
        0, /* = version */
        5, /* = num fields */
        6, /* = field number offset */
        11, /* = property index offset */
        16, /* = field flags offset */
        22, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        23, /* = messageType */
        35, /* = stringMessage */
        49, /* = fileMessage */
        61, /* = speechMessage */
        75, /* = imageMessage */
        88, /* = end-of-string-marker */
        // Field numbers:
        1, /* = messageType */
        2, /* = stringMessage */
        3, /* = fileMessage */
        4, /* = speechMessage */
        5, /* = imageMessage */
        // Property indices:
        0, /* = messageType */
        1, /* = stringMessage */
        3, /* = fileMessage */
        5, /* = speechMessage */
        7, /* = imageMessage */
        // Field flags:
        QtProtobufPrivate::NoFlags, /* = messageType */
        QtProtobufPrivate::Oneof, /* = stringMessage */
        QtProtobufPrivate::Oneof, /* = fileMessage */
        QtProtobufPrivate::Oneof, /* = speechMessage */
        QtProtobufPrivate::Oneof, /* = imageMessage */
    },
    // char_data
    /* metadata char_data: */
    "bite_im.MessageContent\0" /* = full message name */
    /* field char_data: */
    "messageType\0stringMessage\0fileMessage\0speechMessage\0imageMessage\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering MessageContent::propertyOrdering = {
    &qt_protobuf_MessageContent_metadata.data
};

void MessageContent::registerTypes()
{
    qRegisterMetaType<MessageContent>();
    qRegisterMetaType<MessageContentRepeated>();
}

MessageContent::MessageContent()
    : QProtobufMessage(&MessageContent::staticMetaObject),
      dptr(new MessageContent_QtProtobufData)
{
}

MessageContent::MessageContent(const MessageContent &other)
    : QProtobufMessage(other),
      dptr(other.dptr)
{
}
MessageContent &MessageContent::operator =(const MessageContent &other)
{
    QProtobufMessage::operator=(other);
    dptr = other.dptr;
    return *this;
}
MessageContent::MessageContent(MessageContent &&other) noexcept
    : QProtobufMessage(std::move(other)),
      dptr(std::move(other.dptr))
{
}
MessageContent &MessageContent::operator =(MessageContent &&other) noexcept
{
    QProtobufMessage::operator=(std::move(other));
    dptr.swap(other.dptr);
    return *this;
}
bool MessageContent::operator ==(const MessageContent &other) const
{
    return QProtobufMessage::isEqual(*this, other)
        && dptr->m_messageType == other.dptr->m_messageType
        && dptr->m_msg_content == other.dptr->m_msg_content;
}

bool MessageContent::operator !=(const MessageContent &other) const
{
    return !this->operator ==(other);
}

MessageTypeGadget::MessageType MessageContent::messageType() const
{
    return dptr->m_messageType;
}

StringMessageInfo *MessageContent::stringMessage_p() const
{
    return dptr->m_msg_content.holdsField(2) ?
        dptr->m_msg_content.value<StringMessageInfo>() : nullptr;
}

bool MessageContent::hasStringMessage() const
{
    return dptr->m_msg_content.holdsField(2);
}
StringMessageInfo &MessageContent::stringMessage() const
{
    Q_ASSERT(dptr->m_msg_content.holdsField(2));
    return *(dptr->m_msg_content.value<StringMessageInfo>());
}

FileMessageInfo *MessageContent::fileMessage_p() const
{
    return dptr->m_msg_content.holdsField(3) ?
        dptr->m_msg_content.value<FileMessageInfo>() : nullptr;
}

bool MessageContent::hasFileMessage() const
{
    return dptr->m_msg_content.holdsField(3);
}
FileMessageInfo &MessageContent::fileMessage() const
{
    Q_ASSERT(dptr->m_msg_content.holdsField(3));
    return *(dptr->m_msg_content.value<FileMessageInfo>());
}

SpeechMessageInfo *MessageContent::speechMessage_p() const
{
    return dptr->m_msg_content.holdsField(4) ?
        dptr->m_msg_content.value<SpeechMessageInfo>() : nullptr;
}

bool MessageContent::hasSpeechMessage() const
{
    return dptr->m_msg_content.holdsField(4);
}
SpeechMessageInfo &MessageContent::speechMessage() const
{
    Q_ASSERT(dptr->m_msg_content.holdsField(4));
    return *(dptr->m_msg_content.value<SpeechMessageInfo>());
}

ImageMessageInfo *MessageContent::imageMessage_p() const
{
    return dptr->m_msg_content.holdsField(5) ?
        dptr->m_msg_content.value<ImageMessageInfo>() : nullptr;
}

bool MessageContent::hasImageMessage() const
{
    return dptr->m_msg_content.holdsField(5);
}
ImageMessageInfo &MessageContent::imageMessage() const
{
    Q_ASSERT(dptr->m_msg_content.holdsField(5));
    return *(dptr->m_msg_content.value<ImageMessageInfo>());
}

void MessageContent::setMessageType(const MessageTypeGadget::MessageType &messageType)
{
    if (dptr->m_messageType != messageType) {
        dptr.detach();
        dptr->m_messageType = messageType;
    }
}

void MessageContent::setStringMessage(const StringMessageInfo &stringMessage)
{
    if (!dptr->m_msg_content.isEqual(stringMessage, 2)) {
        dptr.detach();
        dptr->m_msg_content.setValue(stringMessage, 2);
    }
}

void MessageContent::setStringMessage_p(StringMessageInfo *stringMessage)
{
    if (dptr->m_msg_content.holdsField(2) &&
        dptr->m_msg_content.value<StringMessageInfo>() == stringMessage)
        return;
    const StringMessageInfo &value = *stringMessage;
    if (!dptr->m_msg_content.isEqual(value, 2)) {
        dptr.detach();
        dptr->m_msg_content.setValue(value, 2);
    }
    delete stringMessage;
}

void MessageContent::setFileMessage(const FileMessageInfo &fileMessage)
{
    if (!dptr->m_msg_content.isEqual(fileMessage, 3)) {
        dptr.detach();
        dptr->m_msg_content.setValue(fileMessage, 3);
    }
}

void MessageContent::setFileMessage_p(FileMessageInfo *fileMessage)
{
    if (dptr->m_msg_content.holdsField(3) &&
        dptr->m_msg_content.value<FileMessageInfo>() == fileMessage)
        return;
    const FileMessageInfo &value = *fileMessage;
    if (!dptr->m_msg_content.isEqual(value, 3)) {
        dptr.detach();
        dptr->m_msg_content.setValue(value, 3);
    }
    delete fileMessage;
}

void MessageContent::setSpeechMessage(const SpeechMessageInfo &speechMessage)
{
    if (!dptr->m_msg_content.isEqual(speechMessage, 4)) {
        dptr.detach();
        dptr->m_msg_content.setValue(speechMessage, 4);
    }
}

void MessageContent::setSpeechMessage_p(SpeechMessageInfo *speechMessage)
{
    if (dptr->m_msg_content.holdsField(4) &&
        dptr->m_msg_content.value<SpeechMessageInfo>() == speechMessage)
        return;
    const SpeechMessageInfo &value = *speechMessage;
    if (!dptr->m_msg_content.isEqual(value, 4)) {
        dptr.detach();
        dptr->m_msg_content.setValue(value, 4);
    }
    delete speechMessage;
}

void MessageContent::setImageMessage(const ImageMessageInfo &imageMessage)
{
    if (!dptr->m_msg_content.isEqual(imageMessage, 5)) {
        dptr.detach();
        dptr->m_msg_content.setValue(imageMessage, 5);
    }
}

void MessageContent::setImageMessage_p(ImageMessageInfo *imageMessage)
{
    if (dptr->m_msg_content.holdsField(5) &&
        dptr->m_msg_content.value<ImageMessageInfo>() == imageMessage)
        return;
    const ImageMessageInfo &value = *imageMessage;
    if (!dptr->m_msg_content.isEqual(value, 5)) {
        dptr.detach();
        dptr->m_msg_content.setValue(value, 5);
    }
    delete imageMessage;
}

MessageContent::Msg_contentFields MessageContent::msg_contentField() const
{
    return static_cast<Msg_contentFields>(dptr->m_msg_content.fieldNumber());
}
void MessageContent::clearMsg_content()
{
    if (dptr->m_msg_content.fieldNumber() != QtProtobuf::InvalidFieldNumber) {
        dptr.detach();
        dptr->m_msg_content = QtProtobufPrivate::QProtobufOneof();
    }
}

class MessageInfo_QtProtobufData : public QSharedData
{
public:
    MessageInfo_QtProtobufData()
        : QSharedData(),
          m_timestamp(0),
          m_sender(nullptr),
          m_message(nullptr)
    {
    }

    MessageInfo_QtProtobufData(const MessageInfo_QtProtobufData &other)
        : QSharedData(other),
          m_messageId(other.m_messageId),
          m_chatSessionId(other.m_chatSessionId),
          m_timestamp(other.m_timestamp),
          m_sender(other.m_sender
                                               ? new UserInfo(*other.m_sender)
                                               : nullptr),
          m_message(other.m_message
                                               ? new MessageContent(*other.m_message)
                                               : nullptr)
    {
    }

    QString m_messageId;
    QString m_chatSessionId;
    QtProtobuf::int64 m_timestamp;
    QtProtobufPrivate::QProtobufLazyMessagePointer<UserInfo> m_sender;
    QtProtobufPrivate::QProtobufLazyMessagePointer<MessageContent> m_message;
};

MessageInfo::~MessageInfo() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 21> qt_protobuf_MessageInfo_uint_data;
    const char qt_protobuf_MessageInfo_char_data[70];
} qt_protobuf_MessageInfo_metadata {
    // data
    {
        0, /* = version */
        5, /* = num fields */
        6, /* = field number offset */
        11, /* = property index offset */
        16, /* = field flags offset */
        19, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        20, /* = messageId */
        30, /* = chatSessionId */
        44, /* = timestamp */
        54, /* = sender */
        61, /* = message */
        69, /* = end-of-string-marker */
        // Field numbers:
        1, /* = messageId */
        2, /* = chatSessionId */
        3, /* = timestamp */
        4, /* = sender */
        5, /* = message */
        // Property indices:
        0, /* = messageId */
        1, /* = chatSessionId */
        2, /* = timestamp */
        3, /* = sender */
        4, /* = message */
        // Field flags:
        QtProtobufPrivate::NoFlags, /* = messageId */
        QtProtobufPrivate::NoFlags, /* = chatSessionId */
        QtProtobufPrivate::NoFlags, /* = timestamp */
        QtProtobufPrivate::NoFlags, /* = sender */
        QtProtobufPrivate::NoFlags, /* = message */
    },
    // char_data
    /* metadata char_data: */
    "bite_im.MessageInfo\0" /* = full message name */
    /* field char_data: */
    "messageId\0chatSessionId\0timestamp\0sender\0message\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering MessageInfo::propertyOrdering = {
    &qt_protobuf_MessageInfo_metadata.data
};

void MessageInfo::registerTypes()
{
    qRegisterMetaType<MessageInfo>();
    qRegisterMetaType<MessageInfoRepeated>();
}

MessageInfo::MessageInfo()
    : QProtobufMessage(&MessageInfo::staticMetaObject),
      dptr(new MessageInfo_QtProtobufData)
{
}

MessageInfo::MessageInfo(const MessageInfo &other)
    : QProtobufMessage(other),
      dptr(other.dptr)
{
}
MessageInfo &MessageInfo::operator =(const MessageInfo &other)
{
    QProtobufMessage::operator=(other);
    dptr = other.dptr;
    return *this;
}
MessageInfo::MessageInfo(MessageInfo &&other) noexcept
    : QProtobufMessage(std::move(other)),
      dptr(std::move(other.dptr))
{
}
MessageInfo &MessageInfo::operator =(MessageInfo &&other) noexcept
{
    QProtobufMessage::operator=(std::move(other));
    dptr.swap(other.dptr);
    return *this;
}
bool MessageInfo::operator ==(const MessageInfo &other) const
{
    return QProtobufMessage::isEqual(*this, other)
        && dptr->m_messageId == other.dptr->m_messageId
        && dptr->m_chatSessionId == other.dptr->m_chatSessionId
        && dptr->m_timestamp == other.dptr->m_timestamp
        && (dptr->m_sender == other.dptr->m_sender
            || *dptr->m_sender == *other.dptr->m_sender)
        && (dptr->m_message == other.dptr->m_message
            || *dptr->m_message == *other.dptr->m_message);
}

bool MessageInfo::operator !=(const MessageInfo &other) const
{
    return !this->operator ==(other);
}

QString MessageInfo::messageId() const
{
    return dptr->m_messageId;
}

QString MessageInfo::chatSessionId() const
{
    return dptr->m_chatSessionId;
}

QtProtobuf::int64 MessageInfo::timestamp() const
{
    return dptr->m_timestamp;
}

UserInfo *MessageInfo::sender_p() const
{
    return dptr->m_sender ? dptr->m_sender.get() : nullptr;
}

bool MessageInfo::hasSender() const
{
    return dptr->m_sender.operator bool();
}

UserInfo &MessageInfo::sender()
{
    dptr.detach();
    return *dptr->m_sender;
}
const UserInfo &MessageInfo::sender() const
{
    return *dptr->m_sender;
}

void MessageInfo::clearSender()
{
    if (dptr->m_sender) {
        dptr.detach();
        dptr->m_sender.reset();
    }
}

MessageContent *MessageInfo::message_p() const
{
    return dptr->m_message ? dptr->m_message.get() : nullptr;
}

bool MessageInfo::hasMessage() const
{
    return dptr->m_message.operator bool();
}

MessageContent &MessageInfo::message()
{
    dptr.detach();
    return *dptr->m_message;
}
const MessageContent &MessageInfo::message() const
{
    return *dptr->m_message;
}

void MessageInfo::clearMessage()
{
    if (dptr->m_message) {
        dptr.detach();
        dptr->m_message.reset();
    }
}

void MessageInfo::setMessageId(const QString &messageId)
{
    if (dptr->m_messageId != messageId) {
        dptr.detach();
        dptr->m_messageId = messageId;
    }
}

void MessageInfo::setChatSessionId(const QString &chatSessionId)
{
    if (dptr->m_chatSessionId != chatSessionId) {
        dptr.detach();
        dptr->m_chatSessionId = chatSessionId;
    }
}

void MessageInfo::setTimestamp(const QtProtobuf::int64 &timestamp)
{
    if (dptr->m_timestamp != timestamp) {
        dptr.detach();
        dptr->m_timestamp = timestamp;
    }
}

void MessageInfo::setSender_p(UserInfo *sender)
{
    if (dptr->m_sender.get() != sender) {
        dptr.detach();
        dptr->m_sender.reset(sender);
    }
}

void MessageInfo::setSender(const UserInfo &sender)
{
    if (*dptr->m_sender != sender) {
        dptr.detach();
        *dptr->m_sender = sender;
    }
}

void MessageInfo::setMessage_p(MessageContent *message)
{
    if (dptr->m_message.get() != message) {
        dptr.detach();
        dptr->m_message.reset(message);
    }
}

void MessageInfo::setMessage(const MessageContent &message)
{
    if (*dptr->m_message != message) {
        dptr.detach();
        *dptr->m_message = message;
    }
}


class Message_QtProtobufData : public QSharedData
{
public:
    Message_QtProtobufData()
        : QSharedData(),
          m_message(nullptr)
    {
    }

    Message_QtProtobufData(const Message_QtProtobufData &other)
        : QSharedData(other),
          m_requestId(other.m_requestId),
          m_message(other.m_message
                                               ? new MessageInfo(*other.m_message)
                                               : nullptr)
    {
    }

    QString m_requestId;
    QtProtobufPrivate::QProtobufLazyMessagePointer<MessageInfo> m_message;
};

Message::~Message() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 9> qt_protobuf_Message_uint_data;
    const char qt_protobuf_Message_char_data[35];
} qt_protobuf_Message_metadata {
    // data
    {
        0, /* = version */
        2, /* = num fields */
        3, /* = field number offset */
        5, /* = property index offset */
        7, /* = field flags offset */
        15, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        16, /* = requestId */
        26, /* = message */
        34, /* = end-of-string-marker */
        // Field numbers:
        1, /* = requestId */
        2, /* = message */
        // Property indices:
        0, /* = requestId */
        1, /* = message */
        // Field flags:
        QtProtobufPrivate::NoFlags, /* = requestId */
        QtProtobufPrivate::NoFlags, /* = message */
    },
    // char_data
    /* metadata char_data: */
    "bite_im.Message\0" /* = full message name */
    /* field char_data: */
    "requestId\0message\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering Message::propertyOrdering = {
    &qt_protobuf_Message_metadata.data
};

void Message::registerTypes()
{
    qRegisterMetaType<Message>();
    qRegisterMetaType<MessageRepeated>();
}

Message::Message()
    : QProtobufMessage(&Message::staticMetaObject),
      dptr(new Message_QtProtobufData)
{
}

Message::Message(const Message &other)
    : QProtobufMessage(other),
      dptr(other.dptr)
{
}
Message &Message::operator =(const Message &other)
{
    QProtobufMessage::operator=(other);
    dptr = other.dptr;
    return *this;
}
Message::Message(Message &&other) noexcept
    : QProtobufMessage(std::move(other)),
      dptr(std::move(other.dptr))
{
}
Message &Message::operator =(Message &&other) noexcept
{
    QProtobufMessage::operator=(std::move(other));
    dptr.swap(other.dptr);
    return *this;
}
bool Message::operator ==(const Message &other) const
{
    return QProtobufMessage::isEqual(*this, other)
        && dptr->m_requestId == other.dptr->m_requestId
        && (dptr->m_message == other.dptr->m_message
            || *dptr->m_message == *other.dptr->m_message);
}

bool Message::operator !=(const Message &other) const
{
    return !this->operator ==(other);
}

QString Message::requestId() const
{
    return dptr->m_requestId;
}

MessageInfo *Message::message_p() const
{
    return dptr->m_message ? dptr->m_message.get() : nullptr;
}

bool Message::hasMessage() const
{
    return dptr->m_message.operator bool();
}

MessageInfo &Message::message()
{
    dptr.detach();
    return *dptr->m_message;
}
const MessageInfo &Message::message() const
{
    return *dptr->m_message;
}

void Message::clearMessage()
{
    if (dptr->m_message) {
        dptr.detach();
        dptr->m_message.reset();
    }
}

void Message::setRequestId(const QString &requestId)
{
    if (dptr->m_requestId != requestId) {
        dptr.detach();
        dptr->m_requestId = requestId;
    }
}

void Message::setMessage_p(MessageInfo *message)
{
    if (dptr->m_message.get() != message) {
        dptr.detach();
        dptr->m_message.reset(message);
    }
}

void Message::setMessage(const MessageInfo &message)
{
    if (*dptr->m_message != message) {
        dptr.detach();
        *dptr->m_message = message;
    }
}


class FileDownloadData_QtProtobufData : public QSharedData
{
public:
    FileDownloadData_QtProtobufData()
        : QSharedData()
    {
    }

    FileDownloadData_QtProtobufData(const FileDownloadData_QtProtobufData &other)
        : QSharedData(other),
          m_fileId(other.m_fileId),
          m_fileContent(other.m_fileContent)
    {
    }

    QString m_fileId;
    QByteArray m_fileContent;
};

FileDownloadData::~FileDownloadData() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 9> qt_protobuf_FileDownloadData_uint_data;
    const char qt_protobuf_FileDownloadData_char_data[45];
} qt_protobuf_FileDownloadData_metadata {
    // data
    {
        0, /* = version */
        2, /* = num fields */
        3, /* = field number offset */
        5, /* = property index offset */
        7, /* = field flags offset */
        24, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        25, /* = fileId */
        32, /* = fileContent */
        44, /* = end-of-string-marker */
        // Field numbers:
        1, /* = fileId */
        2, /* = fileContent */
        // Property indices:
        0, /* = fileId */
        1, /* = fileContent */
        // Field flags:
        QtProtobufPrivate::NoFlags, /* = fileId */
        QtProtobufPrivate::NoFlags, /* = fileContent */
    },
    // char_data
    /* metadata char_data: */
    "bite_im.FileDownloadData\0" /* = full message name */
    /* field char_data: */
    "fileId\0fileContent\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering FileDownloadData::propertyOrdering = {
    &qt_protobuf_FileDownloadData_metadata.data
};

void FileDownloadData::registerTypes()
{
    qRegisterMetaType<FileDownloadData>();
    qRegisterMetaType<FileDownloadDataRepeated>();
}

FileDownloadData::FileDownloadData()
    : QProtobufMessage(&FileDownloadData::staticMetaObject),
      dptr(new FileDownloadData_QtProtobufData)
{
}

FileDownloadData::FileDownloadData(const FileDownloadData &other)
    : QProtobufMessage(other),
      dptr(other.dptr)
{
}
FileDownloadData &FileDownloadData::operator =(const FileDownloadData &other)
{
    QProtobufMessage::operator=(other);
    dptr = other.dptr;
    return *this;
}
FileDownloadData::FileDownloadData(FileDownloadData &&other) noexcept
    : QProtobufMessage(std::move(other)),
      dptr(std::move(other.dptr))
{
}
FileDownloadData &FileDownloadData::operator =(FileDownloadData &&other) noexcept
{
    QProtobufMessage::operator=(std::move(other));
    dptr.swap(other.dptr);
    return *this;
}
bool FileDownloadData::operator ==(const FileDownloadData &other) const
{
    return QProtobufMessage::isEqual(*this, other)
        && dptr->m_fileId == other.dptr->m_fileId
        && dptr->m_fileContent == other.dptr->m_fileContent;
}

bool FileDownloadData::operator !=(const FileDownloadData &other) const
{
    return !this->operator ==(other);
}

QString FileDownloadData::fileId() const
{
    return dptr->m_fileId;
}

QByteArray FileDownloadData::fileContent() const
{
    return dptr->m_fileContent;
}

void FileDownloadData::setFileId(const QString &fileId)
{
    if (dptr->m_fileId != fileId) {
        dptr.detach();
        dptr->m_fileId = fileId;
    }
}

void FileDownloadData::setFileContent(const QByteArray &fileContent)
{
    if (dptr->m_fileContent != fileContent) {
        dptr.detach();
        dptr->m_fileContent = fileContent;
    }
}


class FileUploadData_QtProtobufData : public QSharedData
{
public:
    FileUploadData_QtProtobufData()
        : QSharedData(),
          m_fileSize(0)
    {
    }

    FileUploadData_QtProtobufData(const FileUploadData_QtProtobufData &other)
        : QSharedData(other),
          m_fileName(other.m_fileName),
          m_fileSize(other.m_fileSize),
          m_fileContent(other.m_fileContent)
    {
    }

    QString m_fileName;
    QtProtobuf::int64 m_fileSize;
    QByteArray m_fileContent;
};

FileUploadData::~FileUploadData() = default;

static constexpr struct {
    QtProtobufPrivate::QProtobufPropertyOrdering::Data data;
    const std::array<uint, 13> qt_protobuf_FileUploadData_uint_data;
    const char qt_protobuf_FileUploadData_char_data[54];
} qt_protobuf_FileUploadData_metadata {
    // data
    {
        0, /* = version */
        3, /* = num fields */
        4, /* = field number offset */
        7, /* = property index offset */
        10, /* = field flags offset */
        22, /* = message full name length */
    },
    // uint_data
    {
        // JSON name offsets:
        23, /* = fileName */
        32, /* = fileSize */
        41, /* = fileContent */
        53, /* = end-of-string-marker */
        // Field numbers:
        1, /* = fileName */
        2, /* = fileSize */
        3, /* = fileContent */
        // Property indices:
        0, /* = fileName */
        1, /* = fileSize */
        2, /* = fileContent */
        // Field flags:
        QtProtobufPrivate::NoFlags, /* = fileName */
        QtProtobufPrivate::NoFlags, /* = fileSize */
        QtProtobufPrivate::NoFlags, /* = fileContent */
    },
    // char_data
    /* metadata char_data: */
    "bite_im.FileUploadData\0" /* = full message name */
    /* field char_data: */
    "fileName\0fileSize\0fileContent\0"
};

const QtProtobufPrivate::QProtobufPropertyOrdering FileUploadData::propertyOrdering = {
    &qt_protobuf_FileUploadData_metadata.data
};

void FileUploadData::registerTypes()
{
    qRegisterMetaType<FileUploadData>();
    qRegisterMetaType<FileUploadDataRepeated>();
}

FileUploadData::FileUploadData()
    : QProtobufMessage(&FileUploadData::staticMetaObject),
      dptr(new FileUploadData_QtProtobufData)
{
}

FileUploadData::FileUploadData(const FileUploadData &other)
    : QProtobufMessage(other),
      dptr(other.dptr)
{
}
FileUploadData &FileUploadData::operator =(const FileUploadData &other)
{
    QProtobufMessage::operator=(other);
    dptr = other.dptr;
    return *this;
}
FileUploadData::FileUploadData(FileUploadData &&other) noexcept
    : QProtobufMessage(std::move(other)),
      dptr(std::move(other.dptr))
{
}
FileUploadData &FileUploadData::operator =(FileUploadData &&other) noexcept
{
    QProtobufMessage::operator=(std::move(other));
    dptr.swap(other.dptr);
    return *this;
}
bool FileUploadData::operator ==(const FileUploadData &other) const
{
    return QProtobufMessage::isEqual(*this, other)
        && dptr->m_fileName == other.dptr->m_fileName
        && dptr->m_fileSize == other.dptr->m_fileSize
        && dptr->m_fileContent == other.dptr->m_fileContent;
}

bool FileUploadData::operator !=(const FileUploadData &other) const
{
    return !this->operator ==(other);
}

QString FileUploadData::fileName() const
{
    return dptr->m_fileName;
}

QtProtobuf::int64 FileUploadData::fileSize() const
{
    return dptr->m_fileSize;
}

QByteArray FileUploadData::fileContent() const
{
    return dptr->m_fileContent;
}

void FileUploadData::setFileName(const QString &fileName)
{
    if (dptr->m_fileName != fileName) {
        dptr.detach();
        dptr->m_fileName = fileName;
    }
}

void FileUploadData::setFileSize(const QtProtobuf::int64 &fileSize)
{
    if (dptr->m_fileSize != fileSize) {
        dptr.detach();
        dptr->m_fileSize = fileSize;
    }
}

void FileUploadData::setFileContent(const QByteArray &fileContent)
{
    if (dptr->m_fileContent != fileContent) {
        dptr.detach();
        dptr->m_fileContent = fileContent;
    }
}

} // namespace bite_im

#include "moc_base.qpb.cpp"
